---
layout: post
title: "[김영한 - JPA 기본] #6 다양한 연관관계 매핑"
subtitle: "..."
date: 2022-01-02 16:00 +0900
categories: backend
tags: jpa
comments: true
---

# 연관관계 매핑시 고려사항들

- 다중성
  - 일대다, 등
- 단방향, 양방향
  - 양방향시 연관관계의 주인 고려

## 단방향, 양방향

- #### 테이블
  - 외래 키 하나로 양쪽 조인 가능
  - 방향이라는 개념이 없다 (아래 참고)

```SQL
SELECT M.*
FROM MEMBER M
	JOIN TEAM T
		ON M.MEMBER_ID = T.MEMBER_ID;

SELECT *
FROM TEAM T
	JOIN MEMBER M
		ON T.MEMBER_ID = M.MEMBER_ID;
```

- #### 객체
  - 레퍼런스(참조) 필드가 있는 쪽으로만 참조 가능
  - 한쪽만 참조하면 단방향
  - 양쪽이 서로 참조하면 양방향(사실은 단방향 2개)

## 연관관계의 주인

- 양방향 관계는 참조가 2군데 있는데 둘중 테이블의 외래 키를 관리할 곳을 지정해야 함

  - 그래서 주인은 외래키를 관리하는 참조 필드
  - `insert/update` 가능

- 주인의 반대편: 외래 키에 영향을 주지 않음
  - `read-only`

# 다대일 [N:1] `@ManyToOne`

- `다` 가 연관관계의 주인

  - 반대 방향은 일대다

- 가장 많이 사용하는 연관관계

```java
@Entity
public class Member {
	@ManyToOne
	@JoinColumn(name = "TEAM_ID")
	private Team team;
}
```

만일 반대쪽 방향에도 연관관계를 걸어서 양방향으로 만들고 싶다면?

```java
@Entity
public class Team {
	@OneToMany(mappedBy = "team")
	private Member member;
}
```

# 일대다 [1:N] `@OneToMany`

- `일` 가 연관관계의 주인
- 권장하지 않지만 표준스펙에서 지원하므로 강의 내용에 있다
- `@JoinColumn`을 꼭 사용해야 한다  
  -그렇지 않으면 default로 조인 테이블 전략을 사용함 (중간에 테이블을 하나 추가함) (매핑 테이블)

> public 접근제어자 기본적인 어노테이션 등은 이하 생략합니다 !

```java
class Team {

	...

	@OneToMany
	@JoinColumn(name = "TEAM_ID")
	private List<Member> members = new ArrayList<>();
}
```

> 실행부

```java
tx.begin();

Member member = new Member("user A");
em.persist(member);

Team team = new Team("H.R.");
em.persist(team);

team.getMembers().add(member);
```

> 실행 쿼리

```
Hibernate:
    /* insert hellojpa.domain.Member
        */ insert
        into
            Member
            (age, createDate, description, lastModifiedDate, name, roleType, id)
        values
            (?, ?, ?, ?, ?, ?, ?)
Hibernate:
    /* insert hellojpa.domain.Team
        */ insert
        into
            Team
            (name, TEAM_ID)
        values
            (?, ?)
```

그리고.. 아래가 중요하다 !

```
Hibernate:
    /* create one-to-many row hellojpa.domain.Team.members */ update
        Member
    set
        TEAM_ID=?
    where
        id=?
```

위 실행부를 보면 JPA를 아직 잘 모르는 사람에게 혼동을 줄 수 있다

분명 Update는 team에 했는데 정작 변경은 Member테이블에 되니까 ..

장점보다 단점이 많은 방식이다

단점 정리

- 엔티티(`Team`)가 관리하는 외래 키가 다른 테이블(`MEMBER`)에 있음
- 연관 관계 관계를 위해 추가적인 UPDATE 쿼리 발생

결론

- 일대다 보다는 다대일 양방향이 낫다.. 더 나은건 다대일 단방향

## 충격과 공포의 양방향 매핑.. !

- 놀랍게도 일대다도 양방향이 가능하다 ! 아래 코드를 보자 !

```java
class Member {

	@ManyToOne
	@JoinColumn(name = "TEAM_ID", insertable = false, updatable = false)
	private Team team;

}
```

위 처럼 해주면 된다 !

`insertable`, `updatable` 옵션을 false로 한 이유는 이미 상대편에(Team) 연관관계 주인으로 true로 되어 있기 떄문이다

한쪽에만 write 권한이 있다는 걸 보여주어야 하는 것 같다 둘다 쓰기 권한을 가지면 꼬일 수도 있으니..

문제는 저 옵션을 끄더라도 예외가 발생하지 않는다 ! ㅠㅠ

# 일대일 [1:1] `@OneToOne`

-

# 기타 알려주신 사항들

- 실무에서는 Entitiy 객체에 `setter`를 거의 쓰지 않는다
  - 생성자에서 모두 완성을 시키거나
  - 빌더 패턴을 사용한다
