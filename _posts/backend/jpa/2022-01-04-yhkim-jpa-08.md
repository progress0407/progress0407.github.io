---
layout: post
title: "[김영한 - JPA 기본] #8 프록시와 연관관계 관리"
subtitle: "..."
date: 2022-01-02 16:00 +0900
categories: backend
tags: jpa
comments: true
---

# 프록시

## 프록시의 정의 및 특징

- 실제 클래스를 상속받아서 만들어진 가짜 클래스이다
  - 진짜 클래스는 `Entity target = null` 등으로 받아오는 듯하다
- 사용할 때는 진짜/가짜 유무를 구분하지 않고 사용하면 된다 한다 (이론상)
- 실제 객체의 참조를 보관한다
- `getReference()`를 통해서 프록시 객체를 초기화를 한다
- 처음 사용할 때 한 번만 초기화 한다
  - 초기화할 때 실제 엔티티로 바뀌는 것은 아니다
  - 초기화되면 프록시를 통해 실제 엔티티로 접근이 가능하다
- 프록시 객체는 원본 엔티티를 상속받기 때문에 타입체크시 `==`대신에 `instance of`를 사용하여 비교하자
- 영속 컨텍스트의 도움을 받을 수 없는 준영속(detached) 상태일 때, 프록시를 초기화하면 예외 발생

## 프록시 관련 API들

- 초기화 여부 확인
  - isLoaded
- 강제 초기화
  - Hibernate.initialize(entity)
  - jpa 표준은 강제 초기화가 없기 때문에
    - member.getName() 등을 호출하여 초기화 가능하다..

## 강의에서 보여준 실험 코드들

---

> 핵심 전제 : 조회된 객체(진짜, 가짜) 모두 **==** 연산시 `true`가 나와야 한다

- 1. `find` 조회 후 `getReference`

처음부터 진짜 객체가 조회되므로 가짜 객체가 조회될 필요가 없다

- 2. `getReference` 조회 후 `find`

가짜를 조회한 후 find를 통해 조회하더라도 가짜 객체가 나온다
find로 조회한 것이 꼭 원객체임을 보장할 수 없는 것이다

> REPEATABLE READ
> JPA에서는 같은 트랜잭션이라면 같은 객체임을 보장을 해주어야만 한다

## 즉시 로딩과 지연 로딩

---

### 핵심 이슈

> 개념을 이해하는데 도움이 되는 이슈

```java
List<Member> findMemberList = em.createQuery("select m from Member m", Member.class).getResultList();
out.println("findMemberList = " + findMemberList);
```

위와 같은 JPQL 쿼리는 특별한 설정이 없으면 N+1 문제를 발생시킨다

즉 member객체를 모두 찾은 다음에 각 객체에 대한 team객체를 가져오기 위한 쿼리를 발생한다

내가 작성한 쿼리는 하나(**1**)지만 member가 **N**개일 경우 1+N, 즉 **N+1** 문제를 발생

만일 member가 1000명이고 team이 100명이면 `1000 + 1`의 쿼리가 발생한다

### 해결법

```java
class Member  {

  ...

	@ManyToOne(fetch = FetchType.LAZY) // default는 EAGER 다 !!
	@JoinColumn(name = "TEAM_ID")
	private Team team;
```

위와 같이 `LAZY 로딩`을 별도로 설정해준다 !

### 정리

- **XToOne** 즉 ``@ManyToOne`, @OneToOne 은 즉시로딩을 한다

  - 따라서 예상치 못한 쿼리가 나갈 수 있다
  - `JPQL`에서 N+! 문제 발생

- 모든 연관관계에 지연 로딩을 사용할 것 ! (특히 실무에서)
  - 실무에서 즉시 로딩을 사용하지 말 것 !
- JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라!

### 앞으로 해볼 것들

- 여러 테이블이 묶여 있는 상황에서 즉시, 즉시 로딩을 발생시켜보기
- 자바로 가짜 DB 클래스, Proxy를 만들고 지연 로딩을 만들어보기
  - 기술에 대한 구체적인 상상을 해보는 것 !! 이 목적이다

## 영속성 전이: `CASCADE`

---

- `다대일` 관계에서 `일`의 엔티티를 영속화할 때 `다`도 같이 하고 싶을 때
  - 예: 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.

```java
@OneToMany(mappedBy="parent", cascade=CascadeType.PERSIST)
```

- 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음
  - 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐

### 많이 CASCADE의 종류

- **ALL**: 모두 적용
- **PERSIST**: 영속
- **REMOVE**: 삭제

## 고아 객체

- `다대일`에서 `일`의 연관관계가 끊어진 `다`의 엔티티는 자동 삭제

```java
orphanRemoval = true
```

### 앞으로 해볼 것들 !

---

Casade

- 양방향일때도 적용 가능?
- 한 뎁스가 아닌 여러 뎁스의 경우도 적용 가능?
- self join을 하는 manyToOne일 경우 연쇄적으로 적용가능?
- 이 경우 삭제 로직은 한번만 나가도 될 것으로 보인다 !
- 그러나 연관관계 매핑과는 상관 없는 개념이라 한다.. 이게 무슨?!

한 게시판에 여러 첨부 파일이 잇는 경우 유용
   다대다인 경우는 사용하면 안됀다
-> 오해햇다 . Child의 부모가 파렌트, 멤버 등일때 다 날라갈 수 잇다는 뜻 > 실험해보자 !!
