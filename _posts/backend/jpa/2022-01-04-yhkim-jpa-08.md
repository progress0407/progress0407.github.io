---
layout: post
title: "[김영한 - JPA 기본] #8 프록시와 연관관계 관리"
subtitle: "..."
date: 2022-01-04 16:00 +0900
categories: backend
tags: jpa
comments: true
---

## 프록시 `Proxy`

---

### 그래서 프록시 (Proxy) 가 대체 머야?! ~~ㅁㅇㅁㅇ~~

---

필자가 생각하는 프록시는 크게 두가지 효용을 가진다

> 1. 캐싱
> 2. 공통처리

#### 1. 캐싱

캐싱은 진짜 real 객체를 호출하기엔 비용이 크게 드는 것이다 그래서 일단 정말로 필요한 순간까지 미루다가  
필요 순간이 오면 진짜 객체를 동적으로 생성 혹은 받아와서 그때서야 주는 것이다. 이때 생성된 진짜 객체는 내부적으로 static 등의 필드로 저장되어 관리된다 (`캐싱`)

#### 2. 공통처리

코드를 작성하다보면 핵심 비즈니스 로직 이외의 부가적인 기능 (로깅, 트랜잭션)이 필요할 떄가 있다
이때 이 코드들은 거의 모든 비즈니스 핵심 코드에서 삽입이 되며 코드를 읽거나 유지보수하는데 어려움이 생긴다
이때 프록시 패턴을 이용하면 좋다 !
공통처리 코드를 만들어 놓고 비즈니스 객체의 메서드 호출을 그안에 삽입하는 것이다
이것은 `AOP`의 근간 원리가 된다

### 프록시의 정의 및 특징

---

- 실제 클래스를 상속받아서 만들어진 가짜 클래스이다
  - 진짜 클래스는 `Entity target = null` 등으로 받아오는 듯하다
- 사용할 때는 진짜/가짜 유무를 구분하지 않고 사용하면 된다 한다 (이론상)
- 실제 객체의 참조를 보관한다
- `getReference()`를 통해서 프록시 객체를 초기화를 한다
- 처음 사용할 때 한 번만 초기화 한다
  - 초기화할 때 실제 엔티티로 바뀌는 것은 아니다
  - 초기화되면 프록시를 통해 실제 엔티티로 접근이 가능하다
- 프록시 객체는 원본 엔티티를 상속받기 때문에 타입체크시 `==`대신에 `instance of`를 사용하여 비교하자
- 영속 컨텍스트의 도움을 받을 수 없는 준영속(detached) 상태일 때, 프록시를 초기화하면 예외 발생

### 프록시 관련 API들

---

- 초기화 여부 확인
  - isLoaded
- 강제 초기화
  - Hibernate.initialize(entity)
  - jpa 표준은 강제 초기화가 없기 때문에
    - member.getName() 등을 호출하여 초기화 가능하다..

### 강의에서 보여준 실험 코드들

---

> 핵심 전제 : 조회된 객체(진짜, 가짜) 모두 **==** 연산시 `true`가 나와야 한다

- 1. `find` 조회 후 `getReference`

처음부터 진짜 객체가 조회되므로 가짜 객체가 조회될 필요가 없다

- 2. `getReference` 조회 후 `find`

가짜를 조회한 후 find를 통해 조회하더라도 가짜 객체가 나온다
find로 조회한 것이 꼭 원객체임을 보장할 수 없는 것이다

> REPEATABLE READ
> JPA에서는 같은 트랜잭션이라면 같은 객체임을 보장을 해주어야만 한다

## 즉시 로딩과 지연 로딩

---

### 핵심 이슈

> 개념을 이해하는데 도움이 되는 이슈

```java
List<Member> findMemberList = em.createQuery("select m from Member m", Member.class).getResultList();
out.println("findMemberList = " + findMemberList);
```

위와 같은 JPQL 쿼리는 특별한 설정이 없으면 N+1 문제를 발생시킨다

즉 member객체를 모두 찾은 다음에 각 객체에 대한 team객체를 가져오기 위한 쿼리를 발생한다

내가 작성한 쿼리는 하나(**1**)지만 member가 **N**개일 경우 1+N, 즉 **N+1** 문제를 발생

만일 member가 1000명이고 team이 100명이면 `100 + 1`의 쿼리가 발생한다

### 해결법

```java
class Member  {

  ...

	@ManyToOne(fetch = FetchType.LAZY) // default는 EAGER 다 !!
	@JoinColumn(name = "TEAM_ID")
	private Team team;
```

위와 같이 `LAZY 로딩`을 별도로 설정해준다 !

### 정리

- **XToOne** 즉 ``@ManyToOne`, @OneToOne 은 즉시로딩을 한다

  - 따라서 예상치 못한 쿼리가 나갈 수 있다
  - `JPQL`에서 N+! 문제 발생

- 모든 연관관계에 지연 로딩을 사용할 것 ! (특히 실무에서)
  - 실무에서 즉시 로딩을 사용하지 말 것 !
- JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라!

### 앞으로 해볼 것들

- 여러 테이블이 묶여 있는 상황에서 즉시, 즉시 로딩을 발생시켜보기 (O)
- 자바로 가짜 DB 클래스, Proxy를 만들고 지연 로딩을 만들어보기
  - 기술에 대한 구체적인 상상을 해보는 것 !! 이 목적이다

### 지연, 즉시 로딩 실험

- 여러 테이블이 묶여 있는 상황에서 즉시 로딩을 발생시켜보기

```java
Locker lockerA = Locker.builder().name("locker A").build();
Member userA = Member.builder().name("user A").build();
Team teamA = Team.builder().name("team A").build();

lockerA.mapMember(userA);
teamA.addMembers(userA);

em.persist(teamA);
em.persist(userA);
em.persist(lockerA);

em.flush();
em.clear();

List<Team> teams = em.createQuery("select t from Team t", Team.class).getResultList();
teams.forEach(out::println);
```

locker, member , team은 모두 연관관계를 가지는 객체인데, 이때 모두 eager로딩으로 되어 있다고 전제한다

## 영속성 전이: `CASCADE`

---

- `다대일` 관계에서 `일`의 엔티티를 영속화할 때 `다`도 같이 하고 싶을 때
  - 예: 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.

```java
@OneToMany(mappedBy="parent", cascade=CascadeType.PERSIST)
```

- 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없음
  - 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐

### 많이 CASCADE의 종류

- **ALL**: 모두 적용
- **PERSIST**: 영속
- **REMOVE**: 삭제

## 고아 객체

- `다대일`에서 `일`의 연관관계가 끊어진 `다`의 엔티티는 자동 삭제

```java
orphanRemoval = true
```
