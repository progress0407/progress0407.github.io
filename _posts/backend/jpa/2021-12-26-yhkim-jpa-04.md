---
layout: post
title: "[김영한 - JPA 기본] #4 엔티티 매핑"
subtitle: "..."
date: 2021-12-26 20::00 +0900
categories: backend
tags: wooteco
comments: true
---

# 매핑 어노테이션들

---

- 객체와 테이블 :

| 매핑 대상     | 어노테이션                  |
| ------------- | --------------------------- |
| 객체와 테이블 | `@Entity`, `@Table`         |
| 필드와 컬럼   | `@Column`                   |
| 기본키        | `@Id`                       |
| 연관관계      | `@ManyToOne`, `@JoinColumn` |

# 객체와 테이블

---

- `@Entity`가 붙은 클래스는 JPA가 관리하며, **엔티티**라고 부른다

- 기본 생성자 필수 (public, protected)
  - (리플렉션 등의 기술을 사용하기 때문)

### `@Enttiy`

- 속성: name
  - JPA에서 사용할 엔티티 이름을 지정한다.
  - 기본값: 클래스 이름을 그대로 사용
    - 가급적 기본값을 사용한다.

### `@Table`

- 엔티티와 매핑할 테이블 지정

| 속성                    | 기능 설명                           | 기본값             |
| ----------------------- | ----------------------------------- | ------------------ |
| name                    | 매핑할 테이블 이름                  | 엔티티 이름을 사용 |
| uniqueConstraints (DDL) | DDL 생성 시에 유니크 제약 조건 생성 |

## 데이터베이스 스키마 자동 생성

---

- DDL을 애플리케이션 실행 시점에 자동 생성

- 정말 정말 주의해서 사용해야 한다

> hibernate.hbm2ddl.auto

| 옵션        | 설명                                         |
| ----------- | -------------------------------------------- |
| create      | 기존 테이블 DROP 후 생성 (DROP -> CREATE)    |
| create-drop | create 속성에서 종료 시점에 테이블 DROP      |
| update      | 변경된 내역만 반영                           |
| validate    | 엔티티와 테이블이 정상 매핑되었는지만을 확인 |
| none        | 아무것도 하지 않음                           |

> `validation` 속성에 기존의 없던 컬럼을 추가했을 경우

![image](https://user-images.githubusercontent.com/66164361/147407411-6fe7e080-02b5-4fdb-9a57-459c6a5e8cfe.png)

### 운영상에서는 어떻게 ?

| 환경                | 허용되는 속성        |
| ------------------- | -------------------- |
| 개발 초기 단계      | `create`, `update`   |
| 테스트 서버         | `update`, `validate` |
| 스트에징과 운영서버 | `validate`, `none`   |

- 운영환경에서는 절대 `create`, `create=drop`, `update` 을 사용하면 안된다 !!

가급적이면 개발서버에서도 `update`는 쓰지 않는게 좋다

만일 시스템상에서 자동으로 `DDL`이 나가면 락이 걸리게 된다.. 정말 주의해야 한다

## DDL 생성 기능

```java
@Column(nullable = false, length = 10)
```

- 제약조건 추가 : 회원 이름은 필수, 10자 초과 (X)

![image](https://user-images.githubusercontent.com/66164361/147407602-9a7b68a3-20c5-45f1-8369-9727b1d4bf4b.png)

- 유니크 제약 조건 추가

```java
@Table(uniqueConstraints = {
  @UniqueConstraint(
    name = "NAME_AGE_UNIQUE",
    columnNames = {"NAME", "AGE"}
    )
  }
)
```

# 필드와 컬럼 매핑

---

```java
	@Id
	private Long id;
	// @Column(nullable = false, length = 4)
	private String name;

	private Integer age;

  @Enumerated(EnumType.STRING)
  private RoleType roleType;

	@Temporal(TemporalType.DATE)
	private Date createDate;

	@Temporal(TemporalType.DATE)
	private Date lastModifiedDate;

	@Lob
	private String description;

	@Transient
	private String temp;
```

컬럼 속성에 따른 다양한 매핑들

### Enum

- `@Enumerated` 에는 두가지 속성이 있다
  - EnumType.STRING
    - enum 이름을 저장 (name())
    - 반드시 이 속성을 사용해야 문제가 없다, 문제는 이게 기본값이 아니다
  - EnumType.ORDINAL
    - 순서를 저장 (0부터 시작)
    - 이 속성을 사용했을 때 문제가 있다 (DB값이 읽히지 않음, 순서 변경시 의미 상실)

### 날짜와 시간

- `LocalDate`, `LocalDateTime`, `LocalTime`은 어노테이션 없이 사용한다

- `Date`, `Calendar`의 경우는 아래의 어노테이션을 사용한다
  - @Temporal(TemporalType.DATE)
    - TemporalType.DATE
    - TemporalType.TIME
    - TemporalType.TIMESTAMP

### Lob

- 대용량 데이터

- `CLob`
  - String, char[]
- `Blob`
  - byte[]

# 기본 키 매핑

---

### 기본 키 매핑 어노테이션

```java
@Id @GeneratedValue(strategy = GenerationType.AUTO)
private Long id;
```

### 기본 키 매핑 속성

- 직접 할당: `@Id` 만 사용

- 자동 생성 : `@GeneratedValue`

  - IDENTITY : 데이터베이스에 위임에 위임한다 ex) MySql - auto increment
    - 최초 키 생성시 null로 들어가고  
      DB에서 키를 할당한다
      - 이론상 1차 캐시에도 null이 들어갈것 같ㅈ디만
        키 전략이 IDENTITY인 경우는 바로 persist
  - SEQUENCE : 데이터베이스 시퀀스 오브젝트 사용 ex) Oracle
  - TABLE : 키 생성용 테이블 사용, 모든 DB에서 사용
  - AUTO : 방언(Oracle, MySQL)에 따라 자동 지정, 기본값

###
